<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>GIS: GIS.ShapefileReader.ShapeIndex.cs Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.5 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Packages</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a></div>
<h1>GIS.ShapefileReader.ShapeIndex.cs</h1><a href="GIS_8ShapefileReader_8ShapeIndex_8cs.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">//</span>
00002 <span class="comment">//ShapeIndex.cs</span>
00003 <span class="comment">//</span>
00004 
00024 
00025 <span class="preprocessor">#region Using</span>
00026 <span class="preprocessor"></span><span class="keyword">using</span> System;
00027 <span class="keyword">using</span> System.IO;
00028 <span class="keyword">using</span> System.Drawing;
00029 <span class="keyword">using</span> System.Windows.Forms;
00030 <span class="preprocessor">#endregion</span>
00031 <span class="preprocessor"></span>
00032 <span class="keyword">namespace </span>ShapeDotNet.GIS.ShapefileReader
00033 {
<a name="l00037"></a><a class="code" href="namespaceShapeDotNet_1_1GIS_1_1ShapefileReader.html#a5">00037</a>     <span class="keyword">public</span> <span class="keyword">enum</span> <a class="code" href="namespaceShapeDotNet_1_1GIS_1_1ShapefileReader.html#a5">ShapeType</a> 
00038     {
00039         <a class="code" href="namespaceShapeDotNet_1_1GIS_1_1ShapefileReader.html#a5a0">Null</a>        = 0,
00040         <a class="code" href="namespaceShapeDotNet_1_1GIS_1_1ShapefileReader.html#a5a1">Point</a>       = 1,
00041         <a class="code" href="namespaceShapeDotNet_1_1GIS_1_1ShapefileReader.html#a5a2">Line</a>        = 3,
00042         <a class="code" href="namespaceShapeDotNet_1_1GIS_1_1ShapefileReader.html#a5a3">Polygon</a>     = 5,
00043         <a class="code" href="namespaceShapeDotNet_1_1GIS_1_1ShapefileReader.html#a5a4">Multipoint</a>  = 8 
00044     };
00045 
00046     
00047     
<a name="l00053"></a><a class="code" href="classShapeDotNet_1_1GIS_1_1ShapefileReader_1_1ShapeIndex.html">00053</a>     <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">class </span><a class="code" href="classShapeDotNet_1_1GIS_1_1ShapefileReader_1_1ShapeIndex.html">ShapeIndex</a>
00054     {               
<a name="l00055"></a><a class="code" href="classShapeDotNet_1_1GIS_1_1ShapefileReader_1_1ShapeIndex.html#ShapeDotNet_1_1GIS_1_1ShapefileReader_1_1ShapeIndexp0">00055</a>         <span class="keyword">protected</span> <span class="keywordtype">int</span>               _Version;
<a name="l00056"></a><a class="code" href="classShapeDotNet_1_1GIS_1_1ShapefileReader_1_1ShapeIndex.html#ShapeDotNet_1_1GIS_1_1ShapefileReader_1_1ShapeIndexp1">00056</a>         <span class="keyword">protected</span> <a class="code" href="namespaceShapeDotNet_1_1GIS_1_1ShapefileReader.html#a5">ShapeType</a>         _ShapeType;
<a name="l00057"></a><a class="code" href="classShapeDotNet_1_1GIS_1_1ShapefileReader_1_1ShapeIndex.html#ShapeDotNet_1_1GIS_1_1ShapefileReader_1_1ShapeIndexp2">00057</a>         <span class="keyword">protected</span> string            _Filename;
<a name="l00058"></a><a class="code" href="classShapeDotNet_1_1GIS_1_1ShapefileReader_1_1ShapeIndex.html#ShapeDotNet_1_1GIS_1_1ShapefileReader_1_1ShapeIndexp3">00058</a>         <span class="keyword">protected</span> <span class="keywordtype">int</span>               _IndexFileSize;
<a name="l00059"></a><a class="code" href="classShapeDotNet_1_1GIS_1_1ShapefileReader_1_1ShapeIndex.html#ShapeDotNet_1_1GIS_1_1ShapefileReader_1_1ShapeIndexp4">00059</a>         <span class="keyword">protected</span> <a class="code" href="classShapeDotNet_1_1GIS_1_1RectangleD.html">RectangleD</a>        _extents;
00060 
<a name="l00061"></a><a class="code" href="classShapeDotNet_1_1GIS_1_1ShapefileReader_1_1ShapeIndex.html#ShapeDotNet_1_1GIS_1_1ShapefileReader_1_1ShapeIndexp5">00061</a>         <span class="keyword">protected</span> <span class="keywordtype">int</span>[]             _OffsetOfRecord;
<a name="l00062"></a><a class="code" href="classShapeDotNet_1_1GIS_1_1ShapefileReader_1_1ShapeIndex.html#ShapeDotNet_1_1GIS_1_1ShapefileReader_1_1ShapeIndexp6">00062</a>         <span class="keyword">protected</span> <span class="keywordtype">int</span>[]             _LengthOfRecord;
<a name="l00063"></a><a class="code" href="classShapeDotNet_1_1GIS_1_1ShapefileReader_1_1ShapeIndex.html#ShapeDotNet_1_1GIS_1_1ShapefileReader_1_1ShapeIndexp7">00063</a>         <span class="keyword">protected</span> <span class="keywordtype">int</span>               _FeatureCount;
00064         
<a name="l00065"></a><a class="code" href="classShapeDotNet_1_1GIS_1_1ShapefileReader_1_1ShapeIndex.html#ShapeDotNet_1_1GIS_1_1ShapefileReader_1_1ShapeIndexp8">00065</a>         <span class="keyword">protected</span> <a class="code" href="classShapeDotNet_1_1GIS_1_1VectorFeature.html">VectorFeature</a>[]   _features;
<a name="l00066"></a><a class="code" href="classShapeDotNet_1_1GIS_1_1ShapefileReader_1_1ShapeIndex.html#ShapeDotNet_1_1GIS_1_1ShapefileReader_1_1ShapeIndexp9">00066</a>         <span class="keyword">protected</span> <a class="code" href="classShapeDotNet_1_1GIS_1_1MapMetrics.html">MapMetrics</a>        _mapMetrics;
00067         
00068         
00069         
<a name="l00078"></a><a class="code" href="classShapeDotNet_1_1GIS_1_1ShapefileReader_1_1ShapeIndex.html#ShapeDotNet_1_1GIS_1_1ShapefileReader_1_1ShapeIndexa0">00078</a>         <span class="keyword">public</span> <a class="code" href="classShapeDotNet_1_1GIS_1_1ShapefileReader_1_1ShapeIndex.html">ShapeIndex</a>( string filename, <a class="code" href="classShapeDotNet_1_1GIS_1_1MapMetrics.html">MapMetrics</a> metrics )
00079         {           
00080             _Filename       = filename;
00081             _mapMetrics     = metrics;
00082             _extents        = <span class="keyword">new</span> <a class="code" href="classShapeDotNet_1_1GIS_1_1RectangleD.html">RectangleD</a>();
00083             
00084             <span class="comment">// 1.. 2.. 3.. 4..  8^)</span>
00085             ParseHeader( filename );<span class="comment">// .shx file</span>
00086             ReadIndex( filename ); <span class="comment">// .shx file</span>
00087             LoadFile(); <span class="comment">// .shp file</span>
00088             SetupLabels();
00089         }
00090         
00091         
00092         
00097         <span class="keyword">private</span> <span class="keywordtype">void</span> LoadFile()
00098         {           
00099             FileStream fs       = <span class="keyword">new</span> FileStream( _Filename, FileMode.Open );
00100             BinaryReader br     = <span class="keyword">new</span> BinaryReader( fs );
00101             <a class="code" href="classShapeDotNet_1_1GIS_1_1VectorFeature.html">VectorFeature</a> tempFeature;
00102             <span class="keywordtype">int</span>[] segments;
00103             <span class="keywordtype">int</span> segmentPosition;
00104             <span class="keywordtype">int</span> pointsInSegment;
00105             <a class="code" href="classShapeDotNet_1_1GIS_1_1PointD.html">PointD</a>[] tempPoints;
00106             <a class="code" href="classShapeDotNet_1_1GIS_1_1PointD.html">PointD</a>[] segmentPoints;
00107 
00108             _features = <span class="keyword">new</span> <a class="code" href="classShapeDotNet_1_1GIS_1_1VectorFeature.html">VectorFeature</a>[ _FeatureCount ];
00109 
00110 
00111             <span class="keywordflow">if</span> ( _ShapeType == <a class="code" href="namespaceShapeDotNet_1_1GIS_1_1ShapefileReader.html#a5">ShapeType</a>.Point )
00112             {
00113                 <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> a=0; a &lt; _FeatureCount; ++a ) 
00114                 {
00115                     <span class="comment">// Point types don't have parts (segments) / one point per feature</span>
00116                     tempFeature = <span class="keyword">new</span> VectorFeature( 1, _mapMetrics );
00117                     tempPoints = <span class="keyword">new</span> <a class="code" href="classShapeDotNet_1_1GIS_1_1PointD.html">PointD</a>[ 1 ];
00118 
00119                     fs.Seek( _OffsetOfRecord[ a ], 0 );
00120 
00121                     br.ReadInt32(); <span class="comment">//Record number (not needed)</span>
00122                     br.ReadInt32(); <span class="comment">//Content length (not needed)</span>
00123                     br.ReadInt32(); <span class="comment">//Shape type (not needed)</span>
00124                     tempPoints[ 0 ] = <span class="keyword">new</span> PointD( br.ReadDouble(), br.ReadDouble() );
00125                     
00126                     tempFeature.<a class="code" href="classShapeDotNet_1_1GIS_1_1VectorFeature.html#ShapeDotNet_1_1GIS_1_1VectorFeaturea1">AddSegment</a>( tempPoints );
00127                     _features[ a ] = tempFeature;
00128                 }
00129             }
00130             <span class="keywordflow">else</span>
00131             {           
00132                 <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> a=0; a &lt; _FeatureCount; ++a ) 
00133                 {
00134                     fs.Seek( _OffsetOfRecord[ a ] + 44, 0 );
00135                     
00136                     <span class="comment">// Read the number of parts (segments) and create a new VectorFeature</span>
00137                     tempFeature = <span class="keyword">new</span> VectorFeature( br.ReadInt32(), _mapMetrics ); 
00138 
00139                     fs.Seek( _OffsetOfRecord[ a ], 0 );
00140                     
00141                     br.ReadInt32(); <span class="comment">//Record number (not needed)</span>
00142                     br.ReadInt32(); <span class="comment">//Content length (not needed)</span>
00143                     br.ReadInt32(); <span class="comment">//Shape type (not needed)</span>
00144                     tempFeature.<a class="code" href="classShapeDotNet_1_1GIS_1_1VectorFeature.html#ShapeDotNet_1_1GIS_1_1VectorFeature00">Extents</a>.Xmin = br.ReadDouble();
00145                     tempFeature.<a class="code" href="classShapeDotNet_1_1GIS_1_1VectorFeature.html#ShapeDotNet_1_1GIS_1_1VectorFeature00">Extents</a>.Ymin = br.ReadDouble();
00146                     tempFeature.<a class="code" href="classShapeDotNet_1_1GIS_1_1VectorFeature.html#ShapeDotNet_1_1GIS_1_1VectorFeature00">Extents</a>.Xmax = br.ReadDouble();
00147                     tempFeature.<a class="code" href="classShapeDotNet_1_1GIS_1_1VectorFeature.html#ShapeDotNet_1_1GIS_1_1VectorFeature00">Extents</a>.Ymax = br.ReadDouble();
00148                     br.ReadInt32(); <span class="comment">// Number of parts (segments) gotten earlier</span>
00149                     tempPoints = <span class="keyword">new</span> PointD[ br.ReadInt32() ]; <span class="comment">// Number of points</span>
00150 
00151                     segments = <span class="keyword">new</span> <span class="keywordtype">int</span>[ tempFeature.<a class="code" href="classShapeDotNet_1_1GIS_1_1VectorFeature.html#ShapeDotNet_1_1GIS_1_1VectorFeature04">SegmentCount</a> + 1 ];
00152 
00153                     <span class="comment">//Read in the segment indexes</span>
00154                     <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> b=0; b&lt;tempFeature.<a class="code" href="classShapeDotNet_1_1GIS_1_1VectorFeature.html#ShapeDotNet_1_1GIS_1_1VectorFeature04">SegmentCount</a>; ++b )
00155                     {
00156                         segments[ b ] = br.ReadInt32();
00157                     }
00158                     
00159                     <span class="comment">//Read in *ALL* of the points in the feature</span>
00160                     <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> c=0; c&lt;tempPoints.Length; ++c )
00161                     {
00162                         tempPoints[ c ] = <span class="keyword">new</span> PointD( br.ReadDouble(), br.ReadDouble() );
00163                     }
00164 
00165                     <span class="comment">//Add in an ending point for the inner loop that follows (e) </span>
00166                     segments[ tempFeature.<a class="code" href="classShapeDotNet_1_1GIS_1_1VectorFeature.html#ShapeDotNet_1_1GIS_1_1VectorFeature04">SegmentCount</a> ] = tempPoints.Length;
00167 
00168                     <span class="comment">//Watch your step...</span>
00169                     <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> <a class="code" href="namespaceShapeDotNet_1_1GIS_1_1DbaseReader.html#a10a6">d</a>=0; <a class="code" href="namespaceShapeDotNet_1_1GIS_1_1DbaseReader.html#a10a6">d</a>&lt;tempFeature.<a class="code" href="classShapeDotNet_1_1GIS_1_1VectorFeature.html#ShapeDotNet_1_1GIS_1_1VectorFeature04">SegmentCount</a>; ++<a class="code" href="namespaceShapeDotNet_1_1GIS_1_1DbaseReader.html#a10a6">d</a> )
00170                     {
00171                         pointsInSegment = segments[ <a class="code" href="namespaceShapeDotNet_1_1GIS_1_1DbaseReader.html#a10a6">d</a>+1 ] - segments[ <a class="code" href="namespaceShapeDotNet_1_1GIS_1_1DbaseReader.html#a10a6">d</a> ];
00172                         segmentPoints = <span class="keyword">new</span> PointD[ pointsInSegment ];
00173                         segmentPosition = 0;
00174 
00175                         <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> e=segments[ <a class="code" href="namespaceShapeDotNet_1_1GIS_1_1DbaseReader.html#a10a6">d</a> ]; e&lt;segments[ <a class="code" href="namespaceShapeDotNet_1_1GIS_1_1DbaseReader.html#a10a6">d</a>+1 ]; ++e )
00176                         {
00177                             segmentPoints[ segmentPosition ] = tempPoints[ e ];
00178                             ++segmentPosition;
00179                         }
00180 
00181                         tempFeature.<a class="code" href="classShapeDotNet_1_1GIS_1_1VectorFeature.html#ShapeDotNet_1_1GIS_1_1VectorFeaturea1">AddSegment</a>( segmentPoints );
00182                     }
00183 
00184                     _features[ a ] = tempFeature;
00185                 }
00186             }
00187             
00188             _OffsetOfRecord = null;  <span class="comment">//don't need the info anymore</span>
00189             _LengthOfRecord = null;
00190 
00191             GC.Collect();
00192 
00193             br.Close();
00194             fs.Close();
00195         }
00196         
00197         
00198         
00205         <span class="keyword">private</span> <span class="keywordtype">void</span> ParseHeader( string filename )
00206         {
00207             filename            = filename.Remove( filename.Length - 4, 4 );
00208             filename            += <span class="stringliteral">".shx"</span>;
00209 
00210             FileStream fs       = <span class="keyword">new</span> FileStream( filename, FileMode.Open );
00211             BinaryReader br     = <span class="keyword">new</span> BinaryReader( fs );
00212             
00213             <span class="keywordtype">int</span> i;
00214             <span class="keywordtype">int</span>[] header_a      = <span class="keyword">new</span> <span class="keywordtype">int</span>[ 9 ];
00215             <span class="keywordtype">double</span>[] header_b   = <span class="keyword">new</span> <span class="keywordtype">double</span>[ 8 ];
00216 
00217             <span class="comment">//Read the first part of the header as integers</span>
00218             <span class="keywordflow">for</span> ( i=0; i&lt;9; ++i ) 
00219             {
00220                 header_a[ i ]   = br.ReadInt32();
00221             }
00222             
00223             <span class="comment">//Read the second part of the header as doubles</span>
00224             <span class="keywordflow">for</span> ( i=0; i&lt;8; ++i ) 
00225             {
00226                 header_b[ i ]   = br.ReadDouble();
00227             }
00228             
00229             br.Close();
00230             fs.Close();
00231 
00232             <span class="comment">//File size is reported in the header as a big endian</span>
00233             <span class="comment">//16 bit word.</span>
00234             <span class="comment">//Translating the size to 8 bit little endian.</span>
00235             _IndexFileSize      = 2* SwitchByteOrder( header_a[ 6 ] );
00236             _Version            = header_a[ 7 ];
00237             _ShapeType          = ( <a class="code" href="namespaceShapeDotNet_1_1GIS_1_1ShapefileReader.html#a5">ShapeType</a> ) header_a[ 8 ]; <span class="comment">//cast int to enum</span>
00238             _extents.Xmin       = header_b[ 0 ];
00239             _extents.Xmax       = header_b[ 2 ];
00240             _extents.Ymin       = header_b[ 1 ];
00241             _extents.Ymax       = header_b[ 3 ];        
00242         }
00243         
00244         
00245         
00252         <span class="keyword">private</span> <span class="keywordtype">void</span> ReadIndex( string filename )
00253         {
00254             filename            = filename.Remove( filename.Length - 4, 4 );
00255             filename            += <span class="stringliteral">".shx"</span>;
00256             
00257             FileStream fs       = <span class="keyword">new</span> FileStream( filename, FileMode.Open );
00258             BinaryReader br     = <span class="keyword">new</span> BinaryReader( fs );
00259             <span class="keywordtype">int</span> ibuffer;
00260             
00261             _FeatureCount       = ( _IndexFileSize - 100 ) / 8;
00262             
00263             _OffsetOfRecord     = <span class="keyword">new</span> <span class="keywordtype">int</span>[ _FeatureCount ];
00264             _LengthOfRecord     = <span class="keyword">new</span> <span class="keywordtype">int</span>[ _FeatureCount ];
00265             
00266             fs.Seek( 100, 0 );  <span class="comment">//seek past the file header</span>
00267             
00268             <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> x=0; x &lt; _FeatureCount; ++x ) 
00269             {
00270                 <span class="comment">//value must be multiplied by 2 to convert from the native</span>
00271                 <span class="comment">//16 bit value (word) to an 8 bit value, and convert the</span>
00272                 <span class="comment">//format from big endian to little endian.</span>
00273                 ibuffer = br.ReadInt32();       
00274                 _OffsetOfRecord[ x ] = 2* SwitchByteOrder( ibuffer );
00275 
00276                 <span class="comment">//Add 8 bytes to the length to compensate for the</span>
00277                 <span class="comment">//header at the beginning of each record in the shp file.</span>
00278                 ibuffer = br.ReadInt32();               
00279                 _LengthOfRecord[ x ] = ( 2* SwitchByteOrder( ibuffer ) ) + 8;
00280             }
00281 
00282             br.Close();
00283             fs.Close();
00284         }
00285 
00286 
00287 
00294         <span class="keyword">private</span> <span class="keywordtype">void</span> SetupLabels()
00295         {
00296             <span class="keywordtype">double</span> minx;
00297             <span class="keywordtype">double</span> maxx;
00298             <span class="keywordtype">double</span> miny;
00299             <span class="keywordtype">double</span> maxy;
00300             PointD[] tmpPoints;
00301             <span class="keywordtype">int</span> midPoint;
00302             <span class="keywordtype">int</span> endPoint;
00303             <span class="keywordtype">int</span> segToDraw =0;
00304             <span class="keywordtype">int</span> maxSegPoints =0;
00305             
00306             <span class="keywordflow">if</span> ( _ShapeType == <a class="code" href="namespaceShapeDotNet_1_1GIS_1_1ShapefileReader.html#a5">ShapeType</a>.Polygon ||
00307                 _ShapeType == <a class="code" href="namespaceShapeDotNet_1_1GIS_1_1ShapefileReader.html#a5">ShapeType</a>.Multipoint )
00308             {
00309                 <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> a=0; a&lt; _features.Length; ++a )
00310                 {
00311                     <span class="comment">// Optimal situation</span>
00312                     <span class="keywordflow">if</span> ( _features[a].SegmentCount == 1 )
00313                     {
00314                         _features[a].LabelAnchor = <span class="keyword">new</span> PointD( 
00315                             _features[a].Extents.CenterX, 
00316                             _features[a].Extents.CenterY );
00317 
00318                         <span class="keywordflow">continue</span>;
00319                     } 
00320                     <span class="keywordflow">else</span> 
00321                     {
00322                         <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> b=0; b&lt;_features[a].SegmentCount; ++b )
00323                         {
00324                             tmpPoints = _features[a].GetPoints(b);
00325                             
00326                             <span class="keywordflow">if</span> ( tmpPoints.Length &gt; maxSegPoints )
00327                             {
00328                                 maxSegPoints = tmpPoints.Length;
00329                                 segToDraw = b;
00330                             }
00331                         }
00332                             tmpPoints = _features[ a ].GetPoints( segToDraw );
00333 
00334                             PointD p1 = tmpPoints[ 0 ];
00335                             PointD p2 = tmpPoints[ (<span class="keywordtype">int</span>)tmpPoints.Length /2 ];
00336                     
00337                             <span class="keywordflow">if</span> ( p1.X &lt; p2.X )
00338                             {
00339                                 minx = p1.X;
00340                                 maxx = p2.X;
00341                             } 
00342                             <span class="keywordflow">else</span> 
00343                             {
00344                                 minx = p2.X;
00345                                 maxx = p1.X;
00346                             }
00347 
00348                     
00349                             <span class="keywordflow">if</span> ( p1.Y &lt; p2.Y )
00350                             {
00351                                 miny = p1.Y;
00352                                 maxy = p2.Y;
00353                             } 
00354                             <span class="keywordflow">else</span> 
00355                             {
00356                                 miny = p2.Y;
00357                                 maxy = p1.Y;
00358                             }
00359 
00360                             _features[a].LabelAnchor = <span class="keyword">new</span> PointD( minx + (( maxx - minx)/2), miny + (( maxy - miny)/2) );
00361                             segToDraw =0;
00362                             maxSegPoints =0;
00363                     }
00364                 }
00365             }
00366 
00367             <span class="keywordflow">if</span> ( _ShapeType == <a class="code" href="namespaceShapeDotNet_1_1GIS_1_1ShapefileReader.html#a5">ShapeType</a>.Line )
00368             {
00369                 <span class="keywordtype">double</span> dx, dy;
00370                 <span class="keywordtype">double</span> tmpx, tmpy;
00371                 <span class="keywordtype">double</span> angle = 0.0;
00372 
00373                 <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> a=0; a&lt; _features.Length; ++a )
00374                 {                                       
00375                     tmpPoints = _features[a].GetPoints(0);
00376                     endPoint = tmpPoints.Length - 1;
00377                     
00378                     <span class="comment">// Figure out which point to use as an anchor for the label                 </span>
00379                     midPoint = ( tmpPoints.Length -1 ) / 2;
00380                     dx = tmpPoints[midPoint +1].X - tmpPoints[midPoint].X;
00381                     dy = tmpPoints[midPoint +1].Y - tmpPoints[midPoint].Y;
00382                     
00383                     tmpx = tmpPoints[midPoint].X + ( dx / 2 );
00384                     tmpy = tmpPoints[midPoint].Y + ( dy / 2 );
00385                     
00386                     _features[a].LabelAnchor = <span class="keyword">new</span> PointD( tmpx, tmpy );
00387                     
00388                     <span class="comment">// calculate angle of line                  </span>
00389                     angle = -Math.Atan(dy / dx) + Math.PI / 2<a class="code" href="namespaceShapeDotNet_1_1GIS_1_1DbaseReader.html#a10a6">d</a>;
00390                     angle *= (180<a class="code" href="namespaceShapeDotNet_1_1GIS_1_1DbaseReader.html#a10a6">d</a> / Math.PI); <span class="comment">// convert radians to degrees</span>
00391 
00392                     _features[a].FeatureAngle = (<span class="keywordtype">float</span>) angle - 90; <span class="comment">// -90 text orientation</span>
00393                 }
00394             }
00395         }
00396 
00397         
00398         
<a name="l00404"></a><a class="code" href="classShapeDotNet_1_1GIS_1_1ShapefileReader_1_1ShapeIndex.html#ShapeDotNet_1_1GIS_1_1ShapefileReader_1_1ShapeIndexb0">00404</a>         <span class="keyword">protected</span> <span class="keywordtype">int</span> SwitchByteOrder (<span class="keywordtype">int</span> i) 
00405         {           
00406             byte[] buffer   = <span class="keyword">new</span> byte[4];
00407             buffer          = BitConverter.GetBytes(i);
00408             Array.Reverse( buffer, 0, buffer.Length );
00409             
00410             <span class="keywordflow">return</span> BitConverter.ToInt32(buffer, 0);
00411         }
00412         <span class="comment">//#endregion</span>
00413     }
00414 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue Feb 10 17:52:24 2004 for GIS by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.5 </small></address>
</body>
</html>
